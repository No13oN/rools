# ПРАВИЛА НАПИСАННЯ ДОКУМЕНТАЦІЇ ДЛЯ LLM-ЧИТАЧІВ
## Версія 2.0 | Синтез на основі research (2024–2026)

---

## ПРИНЦИП №0 — МЕТА-ПРИНЦИП

Документацію читає модель, а не людина.
Її мозок — це трансформер з обмеженим контекстним вікном.
Вона не "гортає" — вона токенізує, зважує та ранжує.

Звідси три фундаментальні задачі:
1. **Мінімізувати токени** — кожен зайвий токен витісняє корисний
2. **Максимізувати сигнал** — кожен збережений токен має нести значення
3. **Передбачити запити** — структура має відповідати тому, що модель шукатиме

---

## БЛОК 1: ФОРМАТ І СТРУКТУРА

### 1.1 Markdown — єдиний правильний формат

Markdown перетворюється на tokens майже 1:1 з сенсом.
XML і HTML додають шум: теги їдять контекст, не несучи змісту.
JSON — тільки для структурованих даних, не для пояснень.

```
❌ <section><title>Аутентифікація</title><para>Для автентифікації...</para></section>
✅ ## Аутентифікація
   Для автентифікації...
```

### 1.2 Ієрархія заголовків — це карта для LLM

Модель будує "ментальну карту" документа через заголовки.
Пропуск рівнів (H1 → H3) ламає цю карту — модель отримує хибні зв'язки між розділами.

```
❌ # API Reference
   ### Endpoint POST /users   ← пропуск H2 ламає ієрархію

✅ # API Reference
   ## Endpoint POST /users
   ### Parameters
   ### Response
   ### Errors
```

**Правило: ніколи не пропускати рівень заголовку.**

### 1.3 Повторювані шаблони — це мова для моделі

LLM вчиться на патернах. Якщо кожен endpoint описаний однаково —
модель знає, де шукати параметри, відповіді, помилки.

```markdown
## [Назва endpoint]
`[METHOD] /path`

### Опис
[1–2 речення: що робить]

### Параметри
| Назва | Тип | Обов'язково | Опис |
|-------|-----|-------------|------|
| name  | string | так | Повне ім'я |

### Відповідь
```json
{ "id": "123", "name": "Alice" }
```

### Помилки
- `400` — відсутні обов'язкові поля
- `409` — email вже існує
```

**Правило: один тип об'єкта — один шаблон, завжди.**

---

## БЛОК 2: ТЕРМІНОЛОГІЯ І МОВА

### 2.1 Один термін — одне поняття — завжди

Найбільш руйнівна помилка в документації для LLM:
синоніми для одного поняття.

Модель не знає, що `API key`, `access token`, `auth credential` — одне й те ж.
Вона будує імовірнісну карту зв'язків і **помиляється**.

```
❌ "Налаштуйте API key. Потім використайте access token для запиту.
    Додайте auth credential до заголовку."

✅ "Налаштуйте API key. Потім використайте API key для запиту.
    Додайте API key до заголовку."
```

**Правило: обери термін → зафіксуй його в глосарії → ніколи не відступай.**

### 2.2 Без займенників у технічних секціях

Займенники ("воно", "цей", "той") — це `coreference resolution`.
Для LLM це складна задача, яка призводить до помилок.

```
❌ "Оновіть конфіг і перезапустіть сервер. Якщо він не стартує — перевірте логи."

✅ "Оновіть `config.yaml`. Потім перезапустіть application server.
    Якщо application server не стартує — перевірте логи application server."
```

### 2.3 Скорочення — тільки після визначення

Перше введення: `Large Language Model (LLM)`.
Після цього: тільки `LLM`.
Якщо документ довгий — переозначуй на початку кожного розділу.

---

## БЛОК 3: ЩІЛЬНІСТЬ ІНФОРМАЦІЇ

### 3.1 Принцип token budget

Кожен токен — це ресурс з обмеженого бюджету.
Маркетингові вставки, "water" тексти, пустословство — це токен-злодії.

```
❌ "Наш передовий REST API надає розробникам потужні інструменти
    для взаємодії з нашою платформою нового покоління..."

✅ "REST API для управління користувачами."
```

**Правило: кожне речення повинно нести унікальну інформацію, якої нема в інших.**

### 3.2 Семантична щільність — не те ж саме, що стислість

Коротко ≠ інформативно. Ціль — максимум сенсу на токен.

```
❌ "Якщо виникне помилка — дивіться документацію."  (порожньо)
❌ "Помилка 429 виникає, коли ви надсилаєте занадто багато запитів..." (лонгрід)

✅ "429 Too Many Requests: перевищено ліміт. Зачекайте {retry_after} секунд."
```

### 3.3 Правило "Important First"

LLM зважує початок і кінець токенів сильніше за середину.
Феномен називається "lost in the middle" — інформація в центрі великого документа
витягується гірше.

Для кожного розділу:
- Найважливіша інформація — перші 2–3 речення
- Деталі та edge cases — далі
- Приклади — в кінці, як підкріплення

```
❌ "Перед тим як налаштувати... Варто також зазначити... 
    Важливо: токен дійсний 1 годину."

✅ "Токен дійсний 1 годину. Зберігайте в env variable.
    Для оновлення — [детальніше нижче]."
```

---

## БЛОК 4: КОД І ПРИКЛАДИ

### 4.1 Код у блоках — завжди

Inline-код без форматування — LLM розбирає його неточно,
команди "зливаються" з текстом і мутують у відповідях.

```
❌ Встановіть пакет командою npm install @company/sdk@2.1.0 і потім імпортуйте його.

✅ Встановіть пакет:
   \`\`\`bash
   npm install @company/sdk@2.1.0
   \`\`\`
   Потім імпортуйте:
   \`\`\`typescript
   import { ApiClient } from '@company/sdk';
   \`\`\`
```

### 4.2 Самодостатні приклади (Self-contained)

Кожен приклад коду повинен працювати без контексту з інших розділів.
LLM може витягти один приклад — він повинен бути повним.

```python
# ❌ Неповний — потребує контексту з попереднього розділу
client.authenticate(token)
response = client.get('/users')

# ✅ Повний — розуміється без іншого контексту
import os
from company_sdk import ApiClient

client = ApiClient(api_key=os.environ['API_KEY'])
response = client.get('/users')
print(response.json())
```

### 4.3 Коментарі в коді — пояснюють "чому", не "що"

```python
# ❌ "що" — і так видно з коду
# Отримуємо список користувачів
users = client.get('/users')

# ✅ "чому" — не очевидно з коду
# Використовуємо пагінацію, бо /users повертає max 100 записів
users = client.get('/users', params={'limit': 100, 'offset': 0})
```

---

## БЛОК 5: КОНТЕКСТ І МЕТАДАНІ

### 5.1 Frontmatter — обов'язковий для кожного документа

Метадані допомагають LLM правильно роутити запити
і розуміти, чи є цей документ релевантним.

```yaml
---
title: "Rate Limiting"
category: "API Reference"
audience: "Developers"
level: "Intermediate"
related: ["Authentication", "Error Handling", "Webhooks"]
last_updated: "2025-01-28"
---
```

### 5.2 Явні зв'язки між концепціями

LLM будує граф знань із вашого документа.
Явні посилання дають їй надійні ребра графа замість вгадування.

```
❌ (посилання відсутні, модель сама здогадується)

✅ "Перед використанням API налаштуйте аутентифікацію (→ Authentication).
    При перевищенні лімітів зверніться до Rate Limiting (→ Rate Limiting).
    Для обробки помилок — Error Codes Reference (→ Error Codes)."
```

### 5.3 Q&A секції — прямий "LLM-mode"

Документ у форматі питань-відповідей — це вже майже готовий retrieval chunk.
LLM отримує запит у формі питання → шукає відповідь → знаходить Q&A.

```markdown
## Часті питання

**Q: Скільки запитів я можу зробити за хвилину?**
A: 60 запитів/хвилину для стандартного плану, 600 для Enterprise.

**Q: Що означає помилка 401?**
A: Недійсний або прострочений API key. Перегенеруйте його в Dashboard → Settings.
```

---

## БЛОК 6: ТОКЕН-ЕФЕКТИВНІСТЬ

### 6.1 Правило розміру документа

На основі аналізу реальних llms.txt файлів від Cloudflare, Cursor, Supabase:

```
Один документ / сторінка:    ≤ 10,000 токенів
llms.txt (index файл):        ≤ 10,000 токенів
llms-full.txt (повний сайт):  ≤ 500,000 токенів (для RAG систем)
```

Один токен ≈ 0.75 слова (англійська), ≈ 0.5 слова (кирилиця, ієрогліфи).

### 6.2 Модульна структура замість монолітів

Краще 10 сфокусованих документів по 1,000 токенів,
ніж один документ на 10,000 токенів.

```
docs/
├── authentication.md       # 800 tokens — тільки auth
├── rate-limiting.md        # 600 tokens — тільки rate limits
├── error-codes.md          # 1200 tokens — тільки помилки
├── endpoints/
│   ├── users.md            # 900 tokens — тільки /users
│   ├── orders.md           # 950 tokens — тільки /orders
│   └── webhooks.md         # 700 tokens — тільки webhooks
└── llms.txt                # 800 tokens — index з описами
```

### 6.3 Видаляти — так само важливо, як писати

Регулярний аудит документації на "токен-сміття":
- Повторення одного й того ж в різних словах
- Маркетинговий/PR тон
- Застаріла інформація (без чіткого датування)
- Вступні абзаци типу "У цьому розділі ми розглянемо..."

---

## БЛОК 7: ЗОБРАЖЕННЯ І МЕДІА

### 7.1 Alt-text — це основний контент, не підпис

Для LLM без vision capabilities зображення = alt-text.
Навіть для multimodal моделей alt-text = semantic hooks.

```
❌ <img alt="Diagram" src="...">
❌ <img alt="Рис. 1" src="...">

✅ <img alt="Схема OAuth2 flow: User → App → Authorization Server → 
    Token → App → Resource Server. Кроки: 1. App запитує auth code, 
    2. User підтверджує, 3. App отримує access token, 
    4. App використовує token для API запитів." src="...">
```

### 7.2 Текстовий еквівалент для кожної діаграми

```markdown
![Архітектура системи](diagram.png)

**Текстовий опис архітектури:**
- Client → API Gateway (HTTPS, JWT auth)
- API Gateway → Auth Service (перевірка токену)
- API Gateway → Business Logic (після авторизації)
- Business Logic → PostgreSQL (основні дані)
- Business Logic → Redis (кеш, сесії)
- Business Logic → Message Queue (асинхронні задачі)
```

---

## БЛОК 8: ВЕРСІОНУВАННЯ І FRESHNESS

### 8.1 Дата — в кожному документі

LLM бачить документ без часового контексту.
Без дати вона не може оцінити актуальність.

```yaml
---
last_updated: "2025-01-28"
api_version: "v3.2"
status: "stable"  # stable | beta | deprecated
---
```

### 8.2 Явні deprecation notices

```markdown
> ⚠️ **DEPRECATED** (з v3.0, видалено в v4.0)
> Використовуйте `/api/v3/users` замість `/api/v2/users`.
> Migration guide: [→ Migration v2→v3](./migration-v2-v3.md)
```

### 8.3 Changelog у форматі, зрозумілому для LLM

```markdown
## Changelog

### v3.2 (2025-01-28)
- ADDED: Endpoint `POST /users/bulk` для масового створення
- CHANGED: `GET /users` тепер повертає max 100 записів (було 50)
- FIXED: Помилка 500 при порожньому `email` полі
- DEPRECATED: `GET /users/list` — використовуйте `GET /users`
```

---

## БЛОК 9: llms.txt — СТАНДАРТ 2025

### 9.1 Що це і навіщо

`llms.txt` — index файл у корені вашого doc-сайту.
Аналог `robots.txt` або `sitemap.xml`, але для LLM-читачів.
Прийнятий Anthropic, Cloudflare, Stripe, Google (A2A protocol), 844k+ сайтів.

### 9.2 Правильна структура

```markdown
# [Назва продукту]
> [1–2 речення: що це, для кого, основна цінність]

## Docs
- [Authentication](https://docs.example.com/auth.md): Налаштування API key і OAuth2
- [Rate Limiting](https://docs.example.com/rate-limits.md): Ліміти та retry стратегія
- [Error Codes](https://docs.example.com/errors.md): Повний список помилок API
- [Endpoints](https://docs.example.com/endpoints.md): REST API reference

## Optional
- [Changelog](https://docs.example.com/changelog.md): Історія версій API
- [Migration Guide](https://docs.example.com/migration.md): Upgrade між версіями
```

### 9.3 Критичні правила llms.txt

На основі аналізу помилок від Cloudflare, Cursor, Supabase, Docker:

```
ПРАВИЛО 1: Сам файл ≤ 10,000 токенів
           (Cloudflare порушив — 36,000 токенів тільки ToC)

ПРАВИЛО 2: Лінки ведуть на text/markdown або text/plain
           (Docker і Bitcoin порушили — лінки ведуть на HTML)

ПРАВИЛО 3: Кожен linked документ ≤ 10,000 токенів
           (Supabase порушив — перший документ 800,000 токенів)

ПРАВИЛО 4: Описи лінків — 1 речення, конкретне, без маркетингу
           (не "Дізнайтесь більше про наш потужний API",
            а "Список всіх endpoints з параметрами і прикладами")

ПРАВИЛО 5: Не дублювати контент сайту — тільки найважливіше
```

---

## БЛОК 10: ANTI-PATTERNS — ЩО НІКОЛИ НЕ РОБИТИ

### 10.1 "Стіна тексту"

```
❌ Великий блок тексту без заголовків, без переносів, без структури.
   LLM отримує один величезний chunk, де важлива інформація
   "губиться в середині" і витягується з меншою точністю.
```

### 10.2 Посилання замість контенту

```
❌ "Для деталей дивіться розділ [Аутентифікація]."

Якщо LLM не може слідувати посиланню — інформація недоступна.
Критичний контент повинен бути inline, а не тільки за посиланням.
```

### 10.3 Інформація тільки в зображеннях

```
❌ [Діаграма без alt-text або текстового опису]

Для non-vision моделей це — порожнє місце в контексті.
```

### 10.4 Непослідовні шаблони

```
❌ Endpoint 1: ## Опис → ### Параметри → ### Відповідь
   Endpoint 2: ## Параметри → ## Приклади → ## Що повертає
   Endpoint 3: (взагалі без структури)

LLM не може застосувати вивчений патерн — кожен endpoint
треба розбирати як новий унікальний об'єкт.
```

### 10.5 Зміна термінів без попередження

```
❌ В одному розділі: "auth token"
   В наступному: "bearer token"  
   В API reference: "JWT"
   В прикладах: "access_token"

Це — чотири різних концепції для LLM, навіть якщо це одне й те ж.
```

---

## БЛОК 11: ЧЕКЛИСТ ПЕРЕД ПУБЛІКАЦІЄЮ

### Швидка перевірка (5 хвилин)

```
СТРУКТУРА
□ Заголовки H1→H2→H3 без пропусків
□ Один шаблон для однотипних розділів
□ Frontmatter з title, category, last_updated

ТЕРМІНОЛОГІЯ
□ Кожен термін введено і визначено при першому використанні
□ Немає синонімів для одного поняття
□ Скорочення розшифровано при першому введенні

КОД
□ Весь код в ``` блоках з мовою
□ Кожен приклад самодостатній (запускається без контексту)
□ Команди відокремлені від пояснень

ТОКЕНИ
□ Немає маркетингового тексту
□ Немає пустих вступних речень
□ Важлива інформація — на початку розділу

МЕДІА
□ Кожне зображення має детальний alt-text
□ Є текстовий еквівалент для діаграм

СВІЖІСТЬ
□ Дата оновлення вказана
□ Deprecated елементи позначені
□ API версія вказана
```

### Глибока перевірка (тест з моделлю)

Задайте LLM 5 питань по документу:
1. Технічне фактологічне: "Який ліміт запитів на хвилину?"
2. Процедурне: "Як налаштувати аутентифікацію?"
3. Помилка: "Що означає error 403?"
4. Порівняльне: "Чим відрізняється endpoint A від B?"
5. Edge case: "Що буде якщо передати порожній масив?"

Якщо модель відповідає точно і впевнено — документ готовий.
Якщо хоча б раз каже "я не впевнена" або галюцинує — знайдіть і виправте gap.

---

## КОРОТКА ШПАРГАЛКА

```
ПРИНЦИПИ                    ПРАВИЛО
─────────────────────────────────────────────────
Формат                      Markdown, не HTML/XML
Заголовки                   H1→H2→H3, без пропусків
Шаблони                     1 тип = 1 шаблон, завжди
Термінологія                1 поняття = 1 термін, завжди
Займенники                  Замінювати на явні назви
Код                         В ``` блоках з мовою
Приклади                    Самодостатні (self-contained)
Важливе                     Першим у розділі
Розмір                      ≤ 10,000 токенів на документ
Метадані                    Frontmatter в кожному файлі
Зображення                  Alt-text + текстовий опис
Версіонування               Дата + версія API + статус
llms.txt                    Index файл ≤ 10,000 токенів
                            Лінки → тільки Markdown
```

---
